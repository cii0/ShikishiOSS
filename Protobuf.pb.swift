// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Protobuf.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2021 Cii
//
// This file is part of Shikishi.
//
// Shikishi is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Shikishi is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Shikishi.  If not, see <http://www.gnu.org/licenses/>.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum PBRGBColorSpace: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case sRgb // = 0
  case UNRECOGNIZED(Int)

  init() {
    self = .sRgb
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sRgb
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .sRgb: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PBRGBColorSpace: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PBRGBColorSpace] = [
    .sRgb,
  ]
}

#endif  // swift(>=4.2)

enum PBOrientation: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case horizontal // = 0
  case vertical // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .horizontal
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .horizontal
    case 1: self = .vertical
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .horizontal: return 0
    case .vertical: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PBOrientation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PBOrientation] = [
    .horizontal,
    .vertical,
  ]
}

#endif  // swift(>=4.2)

enum PBRectCorner: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case minXminY // = 0
  case minXmaxY // = 1
  case maxXminY // = 2
  case maxXmaxY // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .minXminY
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .minXminY
    case 1: self = .minXmaxY
    case 2: self = .maxXminY
    case 3: self = .maxXmaxY
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .minXminY: return 0
    case .minXmaxY: return 1
    case .maxXminY: return 2
    case .maxXmaxY: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PBRectCorner: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PBRectCorner] = [
    .minXminY,
    .minXmaxY,
    .maxXminY,
    .maxXmaxY,
  ]
}

#endif  // swift(>=4.2)

struct PBPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Double = 0

  var y: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBIntPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Int64 = 0

  var y: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBSize {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var width: Double = 0

  var height: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBRect {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var origin: PBPoint {
    get {return _origin ?? PBPoint()}
    set {_origin = newValue}
  }
  /// Returns true if `origin` has been explicitly set.
  var hasOrigin: Bool {return self._origin != nil}
  /// Clears the value of `origin`. Subsequent reads from it will return its default value.
  mutating func clearOrigin() {self._origin = nil}

  var size: PBSize {
    get {return _size ?? PBSize()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _origin: PBPoint? = nil
  fileprivate var _size: PBSize? = nil
}

struct PBAttitude {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var position: PBPoint {
    get {return _position ?? PBPoint()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  var scale: PBSize {
    get {return _scale ?? PBSize()}
    set {_scale = newValue}
  }
  /// Returns true if `scale` has been explicitly set.
  var hasScale: Bool {return self._scale != nil}
  /// Clears the value of `scale`. Subsequent reads from it will return its default value.
  mutating func clearScale() {self._scale = nil}

  var rotation: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _position: PBPoint? = nil
  fileprivate var _scale: PBSize? = nil
}

struct PBLCHA {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var l: Double = 0

  var c: Double = 0

  var h: Double = 0

  var a: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBRGBA {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var r: Float = 0

  var g: Float = 0

  var b: Float = 0

  var a: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBColor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lcha: PBLCHA {
    get {return _lcha ?? PBLCHA()}
    set {_lcha = newValue}
  }
  /// Returns true if `lcha` has been explicitly set.
  var hasLcha: Bool {return self._lcha != nil}
  /// Clears the value of `lcha`. Subsequent reads from it will return its default value.
  mutating func clearLcha() {self._lcha = nil}

  var rgba: PBRGBA {
    get {return _rgba ?? PBRGBA()}
    set {_rgba = newValue}
  }
  /// Returns true if `rgba` has been explicitly set.
  var hasRgba: Bool {return self._rgba != nil}
  /// Clears the value of `rgba`. Subsequent reads from it will return its default value.
  mutating func clearRgba() {self._rgba = nil}

  var rgbColorSpace: PBRGBColorSpace = .sRgb

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lcha: PBLCHA? = nil
  fileprivate var _rgba: PBRGBA? = nil
}

struct PBUUID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBUUColor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: PBColor {
    get {return _value ?? PBColor()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var id: PBUUID {
    get {return _id ?? PBUUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: PBColor? = nil
  fileprivate var _id: PBUUID? = nil
}

struct PBLine {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var controls: [PBLine.PBControl] = []

  var size: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct PBControl {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var point: PBPoint {
      get {return _point ?? PBPoint()}
      set {_point = newValue}
    }
    /// Returns true if `point` has been explicitly set.
    var hasPoint: Bool {return self._point != nil}
    /// Clears the value of `point`. Subsequent reads from it will return its default value.
    mutating func clearPoint() {self._point = nil}

    var weight: Double = 0

    var pressure: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _point: PBPoint? = nil
  }

  init() {}
}

struct PBPolygon {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var points: [PBPoint] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBPlane {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var polygon: PBPolygon {
    get {return _polygon ?? PBPolygon()}
    set {_polygon = newValue}
  }
  /// Returns true if `polygon` has been explicitly set.
  var hasPolygon: Bool {return self._polygon != nil}
  /// Clears the value of `polygon`. Subsequent reads from it will return its default value.
  mutating func clearPolygon() {self._polygon = nil}

  var uuColor: PBUUColor {
    get {return _uuColor ?? PBUUColor()}
    set {_uuColor = newValue}
  }
  /// Returns true if `uuColor` has been explicitly set.
  var hasUuColor: Bool {return self._uuColor != nil}
  /// Clears the value of `uuColor`. Subsequent reads from it will return its default value.
  mutating func clearUuColor() {self._uuColor = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _polygon: PBPolygon? = nil
  fileprivate var _uuColor: PBUUColor? = nil
}

struct PBPicture {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lines: [PBLine] = []

  var planes: [PBPlane] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBText {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var string: String = String()

  var orientation: PBOrientation = .horizontal

  var size: Double = 0

  var widthCount: Double = 0

  var origin: PBPoint {
    get {return _origin ?? PBPoint()}
    set {_origin = newValue}
  }
  /// Returns true if `origin` has been explicitly set.
  var hasOrigin: Bool {return self._origin != nil}
  /// Clears the value of `origin`. Subsequent reads from it will return its default value.
  mutating func clearOrigin() {self._origin = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _origin: PBPoint? = nil
}

struct PBBorder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var location: Double = 0

  var orientation: PBOrientation = .horizontal

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBIntPointStringDic {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Dictionary<String,PBIntPoint> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBStringIntPointDicElement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: PBIntPoint {
    get {return _key ?? PBIntPoint()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _key: PBIntPoint? = nil
}

struct PBStringIntPointDic {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBStringIntPointDicElement] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBSheet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var picture: PBPicture {
    get {return _picture ?? PBPicture()}
    set {_picture = newValue}
  }
  /// Returns true if `picture` has been explicitly set.
  var hasPicture: Bool {return self._picture != nil}
  /// Clears the value of `picture`. Subsequent reads from it will return its default value.
  mutating func clearPicture() {self._picture = nil}

  var draftPicture: PBPicture {
    get {return _draftPicture ?? PBPicture()}
    set {_draftPicture = newValue}
  }
  /// Returns true if `draftPicture` has been explicitly set.
  var hasDraftPicture: Bool {return self._draftPicture != nil}
  /// Clears the value of `draftPicture`. Subsequent reads from it will return its default value.
  mutating func clearDraftPicture() {self._draftPicture = nil}

  var texts: [PBText] = []

  var borders: [PBBorder] = []

  var backgroundUucolor: PBUUColor {
    get {return _backgroundUucolor ?? PBUUColor()}
    set {_backgroundUucolor = newValue}
  }
  /// Returns true if `backgroundUucolor` has been explicitly set.
  var hasBackgroundUucolor: Bool {return self._backgroundUucolor != nil}
  /// Clears the value of `backgroundUucolor`. Subsequent reads from it will return its default value.
  mutating func clearBackgroundUucolor() {self._backgroundUucolor = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _picture: PBPicture? = nil
  fileprivate var _draftPicture: PBPicture? = nil
  fileprivate var _backgroundUucolor: PBUUColor? = nil
}

struct PBWorld {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sheetPositions: PBIntPointStringDic {
    get {return _sheetPositions ?? PBIntPointStringDic()}
    set {_sheetPositions = newValue}
  }
  /// Returns true if `sheetPositions` has been explicitly set.
  var hasSheetPositions: Bool {return self._sheetPositions != nil}
  /// Clears the value of `sheetPositions`. Subsequent reads from it will return its default value.
  mutating func clearSheetPositions() {self._sheetPositions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sheetPositions: PBIntPointStringDic? = nil
}

struct PBCornerRectValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rect: PBRect {
    get {return _rect ?? PBRect()}
    set {_rect = newValue}
  }
  /// Returns true if `rect` has been explicitly set.
  var hasRect: Bool {return self._rect != nil}
  /// Clears the value of `rect`. Subsequent reads from it will return its default value.
  mutating func clearRect() {self._rect = nil}

  var rectCorner: PBRectCorner = .minXminY

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rect: PBRect? = nil
}

struct PBCornerRectValueArray {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBCornerRectValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBFinding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var worldPosition: PBPoint {
    get {return _worldPosition ?? PBPoint()}
    set {_worldPosition = newValue}
  }
  /// Returns true if `worldPosition` has been explicitly set.
  var hasWorldPosition: Bool {return self._worldPosition != nil}
  /// Clears the value of `worldPosition`. Subsequent reads from it will return its default value.
  mutating func clearWorldPosition() {self._worldPosition = nil}

  var string: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _worldPosition: PBPoint? = nil
}

struct PBIntIndexValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Int64 = 0

  var index: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBLineIndexValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: PBLine {
    get {return _value ?? PBLine()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var index: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: PBLine? = nil
}

struct PBPlaneIndexValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: PBPlane {
    get {return _value ?? PBPlane()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var index: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: PBPlane? = nil
}

struct PBTextIndexValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: PBText {
    get {return _value ?? PBText()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var index: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: PBText? = nil
}

struct PBBorderIndexValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: PBBorder {
    get {return _value ?? PBBorder()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var index: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: PBBorder? = nil
}

struct PBColorValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuColor: PBUUColor {
    get {return _uuColor ?? PBUUColor()}
    set {_uuColor = newValue}
  }
  /// Returns true if `uuColor` has been explicitly set.
  var hasUuColor: Bool {return self._uuColor != nil}
  /// Clears the value of `uuColor`. Subsequent reads from it will return its default value.
  mutating func clearUuColor() {self._uuColor = nil}

  var planeIndexes: [Int64] = []

  var isBackground: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _uuColor: PBUUColor? = nil
}

struct PBIntClosedRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lowerBound: Int64 = 0

  var upperBound: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBPlaneValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var planes: [PBPlane] = []

  var moveIndexValues: [PBIntIndexValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBTextValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var string: String = String()

  var replacedRange: PBIntClosedRange {
    get {return _replacedRange ?? PBIntClosedRange()}
    set {_replacedRange = newValue}
  }
  /// Returns true if `replacedRange` has been explicitly set.
  var hasReplacedRange: Bool {return self._replacedRange != nil}
  /// Clears the value of `replacedRange`. Subsequent reads from it will return its default value.
  mutating func clearReplacedRange() {self._replacedRange = nil}

  var originOptional: PBTextValue.OneOf_OriginOptional? = nil

  var origin: PBPoint {
    get {
      if case .origin(let v)? = originOptional {return v}
      return PBPoint()
    }
    set {originOptional = .origin(newValue)}
  }

  var sizeOptional: PBTextValue.OneOf_SizeOptional? = nil

  var size: Double {
    get {
      if case .size(let v)? = sizeOptional {return v}
      return 0
    }
    set {sizeOptional = .size(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_OriginOptional: Equatable {
    case origin(PBPoint)

  #if !swift(>=4.1)
    static func ==(lhs: PBTextValue.OneOf_OriginOptional, rhs: PBTextValue.OneOf_OriginOptional) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.origin, .origin): return {
        guard case .origin(let l) = lhs, case .origin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  enum OneOf_SizeOptional: Equatable {
    case size(Double)

  #if !swift(>=4.1)
    static func ==(lhs: PBTextValue.OneOf_SizeOptional, rhs: PBTextValue.OneOf_SizeOptional) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.size, .size): return {
        guard case .size(let l) = lhs, case .size(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  init() {}

  fileprivate var _replacedRange: PBIntClosedRange? = nil
}

struct PBTextValueIndexValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: PBTextValue {
    get {return _value ?? PBTextValue()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var index: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: PBTextValue? = nil
}

struct PBSheetValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lines: [PBLine] = []

  var planes: [PBPlane] = []

  var texts: [PBText] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBInt64Array {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [Int64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBLineArray {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBLine] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBPlaneArray {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBPlane] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBIntPointArray {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBIntPoint] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBIntIndexValueArray {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBIntIndexValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBLineIndexValueArray {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBLineIndexValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBPlaneIndexValueArray {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBPlaneIndexValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBTextIndexValueArray {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBTextIndexValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBBorderIndexValueArray {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBBorderIndexValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBSheetUndoItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: PBSheetUndoItem.OneOf_Value? = nil

  var appendLine: PBLine {
    get {
      if case .appendLine(let v)? = value {return v}
      return PBLine()
    }
    set {value = .appendLine(newValue)}
  }

  var appendLines: PBLineArray {
    get {
      if case .appendLines(let v)? = value {return v}
      return PBLineArray()
    }
    set {value = .appendLines(newValue)}
  }

  var appendPlanes: PBPlaneArray {
    get {
      if case .appendPlanes(let v)? = value {return v}
      return PBPlaneArray()
    }
    set {value = .appendPlanes(newValue)}
  }

  var removeLastLines: Int64 {
    get {
      if case .removeLastLines(let v)? = value {return v}
      return 0
    }
    set {value = .removeLastLines(newValue)}
  }

  var removeLastPlanes: Int64 {
    get {
      if case .removeLastPlanes(let v)? = value {return v}
      return 0
    }
    set {value = .removeLastPlanes(newValue)}
  }

  var insertLines: PBLineIndexValueArray {
    get {
      if case .insertLines(let v)? = value {return v}
      return PBLineIndexValueArray()
    }
    set {value = .insertLines(newValue)}
  }

  var insertPlanes: PBPlaneIndexValueArray {
    get {
      if case .insertPlanes(let v)? = value {return v}
      return PBPlaneIndexValueArray()
    }
    set {value = .insertPlanes(newValue)}
  }

  var removeLines: PBInt64Array {
    get {
      if case .removeLines(let v)? = value {return v}
      return PBInt64Array()
    }
    set {value = .removeLines(newValue)}
  }

  var removePlanes: PBInt64Array {
    get {
      if case .removePlanes(let v)? = value {return v}
      return PBInt64Array()
    }
    set {value = .removePlanes(newValue)}
  }

  var setPlaneValue: PBPlaneValue {
    get {
      if case .setPlaneValue(let v)? = value {return v}
      return PBPlaneValue()
    }
    set {value = .setPlaneValue(newValue)}
  }

  var changeToDraft: Bool {
    get {
      if case .changeToDraft(let v)? = value {return v}
      return false
    }
    set {value = .changeToDraft(newValue)}
  }

  var setPicture: PBPicture {
    get {
      if case .setPicture(let v)? = value {return v}
      return PBPicture()
    }
    set {value = .setPicture(newValue)}
  }

  var insertDraftLines: PBLineIndexValueArray {
    get {
      if case .insertDraftLines(let v)? = value {return v}
      return PBLineIndexValueArray()
    }
    set {value = .insertDraftLines(newValue)}
  }

  var insertDraftPlanes: PBPlaneIndexValueArray {
    get {
      if case .insertDraftPlanes(let v)? = value {return v}
      return PBPlaneIndexValueArray()
    }
    set {value = .insertDraftPlanes(newValue)}
  }

  var removeDraftLines: PBInt64Array {
    get {
      if case .removeDraftLines(let v)? = value {return v}
      return PBInt64Array()
    }
    set {value = .removeDraftLines(newValue)}
  }

  var removeDraftPlanes: PBInt64Array {
    get {
      if case .removeDraftPlanes(let v)? = value {return v}
      return PBInt64Array()
    }
    set {value = .removeDraftPlanes(newValue)}
  }

  var setDraftPicture: PBPicture {
    get {
      if case .setDraftPicture(let v)? = value {return v}
      return PBPicture()
    }
    set {value = .setDraftPicture(newValue)}
  }

  var insertTexts: PBTextIndexValueArray {
    get {
      if case .insertTexts(let v)? = value {return v}
      return PBTextIndexValueArray()
    }
    set {value = .insertTexts(newValue)}
  }

  var removeTexts: PBInt64Array {
    get {
      if case .removeTexts(let v)? = value {return v}
      return PBInt64Array()
    }
    set {value = .removeTexts(newValue)}
  }

  var replaceString: PBTextValueIndexValue {
    get {
      if case .replaceString(let v)? = value {return v}
      return PBTextValueIndexValue()
    }
    set {value = .replaceString(newValue)}
  }

  var changedColors: PBColorValue {
    get {
      if case .changedColors(let v)? = value {return v}
      return PBColorValue()
    }
    set {value = .changedColors(newValue)}
  }

  var insertBorders: PBBorderIndexValueArray {
    get {
      if case .insertBorders(let v)? = value {return v}
      return PBBorderIndexValueArray()
    }
    set {value = .insertBorders(newValue)}
  }

  var removeBorders: PBInt64Array {
    get {
      if case .removeBorders(let v)? = value {return v}
      return PBInt64Array()
    }
    set {value = .removeBorders(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case appendLine(PBLine)
    case appendLines(PBLineArray)
    case appendPlanes(PBPlaneArray)
    case removeLastLines(Int64)
    case removeLastPlanes(Int64)
    case insertLines(PBLineIndexValueArray)
    case insertPlanes(PBPlaneIndexValueArray)
    case removeLines(PBInt64Array)
    case removePlanes(PBInt64Array)
    case setPlaneValue(PBPlaneValue)
    case changeToDraft(Bool)
    case setPicture(PBPicture)
    case insertDraftLines(PBLineIndexValueArray)
    case insertDraftPlanes(PBPlaneIndexValueArray)
    case removeDraftLines(PBInt64Array)
    case removeDraftPlanes(PBInt64Array)
    case setDraftPicture(PBPicture)
    case insertTexts(PBTextIndexValueArray)
    case removeTexts(PBInt64Array)
    case replaceString(PBTextValueIndexValue)
    case changedColors(PBColorValue)
    case insertBorders(PBBorderIndexValueArray)
    case removeBorders(PBInt64Array)

  #if !swift(>=4.1)
    static func ==(lhs: PBSheetUndoItem.OneOf_Value, rhs: PBSheetUndoItem.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.appendLine, .appendLine): return {
        guard case .appendLine(let l) = lhs, case .appendLine(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appendLines, .appendLines): return {
        guard case .appendLines(let l) = lhs, case .appendLines(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appendPlanes, .appendPlanes): return {
        guard case .appendPlanes(let l) = lhs, case .appendPlanes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.removeLastLines, .removeLastLines): return {
        guard case .removeLastLines(let l) = lhs, case .removeLastLines(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.removeLastPlanes, .removeLastPlanes): return {
        guard case .removeLastPlanes(let l) = lhs, case .removeLastPlanes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.insertLines, .insertLines): return {
        guard case .insertLines(let l) = lhs, case .insertLines(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.insertPlanes, .insertPlanes): return {
        guard case .insertPlanes(let l) = lhs, case .insertPlanes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.removeLines, .removeLines): return {
        guard case .removeLines(let l) = lhs, case .removeLines(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.removePlanes, .removePlanes): return {
        guard case .removePlanes(let l) = lhs, case .removePlanes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setPlaneValue, .setPlaneValue): return {
        guard case .setPlaneValue(let l) = lhs, case .setPlaneValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.changeToDraft, .changeToDraft): return {
        guard case .changeToDraft(let l) = lhs, case .changeToDraft(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setPicture, .setPicture): return {
        guard case .setPicture(let l) = lhs, case .setPicture(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.insertDraftLines, .insertDraftLines): return {
        guard case .insertDraftLines(let l) = lhs, case .insertDraftLines(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.insertDraftPlanes, .insertDraftPlanes): return {
        guard case .insertDraftPlanes(let l) = lhs, case .insertDraftPlanes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.removeDraftLines, .removeDraftLines): return {
        guard case .removeDraftLines(let l) = lhs, case .removeDraftLines(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.removeDraftPlanes, .removeDraftPlanes): return {
        guard case .removeDraftPlanes(let l) = lhs, case .removeDraftPlanes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setDraftPicture, .setDraftPicture): return {
        guard case .setDraftPicture(let l) = lhs, case .setDraftPicture(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.insertTexts, .insertTexts): return {
        guard case .insertTexts(let l) = lhs, case .insertTexts(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.removeTexts, .removeTexts): return {
        guard case .removeTexts(let l) = lhs, case .removeTexts(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.replaceString, .replaceString): return {
        guard case .replaceString(let l) = lhs, case .replaceString(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.changedColors, .changedColors): return {
        guard case .changedColors(let l) = lhs, case .changedColors(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.insertBorders, .insertBorders): return {
        guard case .insertBorders(let l) = lhs, case .insertBorders(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.removeBorders, .removeBorders): return {
        guard case .removeBorders(let l) = lhs, case .removeBorders(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct PBWorldUndoItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: PBWorldUndoItem.OneOf_Value? = nil

  var insertSheets: PBStringIntPointDic {
    get {
      if case .insertSheets(let v)? = value {return v}
      return PBStringIntPointDic()
    }
    set {value = .insertSheets(newValue)}
  }

  var removeSheets: PBIntPointArray {
    get {
      if case .removeSheets(let v)? = value {return v}
      return PBIntPointArray()
    }
    set {value = .removeSheets(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case insertSheets(PBStringIntPointDic)
    case removeSheets(PBIntPointArray)

  #if !swift(>=4.1)
    static func ==(lhs: PBWorldUndoItem.OneOf_Value, rhs: PBWorldUndoItem.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.insertSheets, .insertSheets): return {
        guard case .insertSheets(let l) = lhs, case .insertSheets(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.removeSheets, .removeSheets): return {
        guard case .removeSheets(let l) = lhs, case .removeSheets(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct PBUndoDataValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var undoItemData: Data = Data()

  var redoItemData: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBUndoGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var values: [PBUndoDataValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBBranch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var groups: [PBUndoGroup] = []

  var childrenCount: Int64 = 0

  var selectedChildIndexOptional: PBBranch.OneOf_SelectedChildIndexOptional? = nil

  var selectedChildIndex: Int64 {
    get {
      if case .selectedChildIndex(let v)? = selectedChildIndexOptional {return v}
      return 0
    }
    set {selectedChildIndexOptional = .selectedChildIndex(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SelectedChildIndexOptional: Equatable {
    case selectedChildIndex(Int64)

  #if !swift(>=4.1)
    static func ==(lhs: PBBranch.OneOf_SelectedChildIndexOptional, rhs: PBBranch.OneOf_SelectedChildIndexOptional) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.selectedChildIndex, .selectedChildIndex): return {
        guard case .selectedChildIndex(let l) = lhs, case .selectedChildIndex(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  init() {}
}

struct PBBranchCoder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var allBranches: [PBBranch] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBHistory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var branchCoder: PBBranchCoder {
    get {return _branchCoder ?? PBBranchCoder()}
    set {_branchCoder = newValue}
  }
  /// Returns true if `branchCoder` has been explicitly set.
  var hasBranchCoder: Bool {return self._branchCoder != nil}
  /// Clears the value of `branchCoder`. Subsequent reads from it will return its default value.
  mutating func clearBranchCoder() {self._branchCoder = nil}

  var currentVersionIndex: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _branchCoder: PBBranchCoder? = nil
}

struct PBCopiedSheetsValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deltaPoint: PBPoint {
    get {return _deltaPoint ?? PBPoint()}
    set {_deltaPoint = newValue}
  }
  /// Returns true if `deltaPoint` has been explicitly set.
  var hasDeltaPoint: Bool {return self._deltaPoint != nil}
  /// Clears the value of `deltaPoint`. Subsequent reads from it will return its default value.
  mutating func clearDeltaPoint() {self._deltaPoint = nil}

  var sheetIds: PBStringIntPointDic {
    get {return _sheetIds ?? PBStringIntPointDic()}
    set {_sheetIds = newValue}
  }
  /// Returns true if `sheetIds` has been explicitly set.
  var hasSheetIds: Bool {return self._sheetIds != nil}
  /// Clears the value of `sheetIds`. Subsequent reads from it will return its default value.
  mutating func clearSheetIds() {self._sheetIds = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _deltaPoint: PBPoint? = nil
  fileprivate var _sheetIds: PBStringIntPointDic? = nil
}

struct PBPlanesValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var planes: [PBPlane] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBPastableObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: PBPastableObject.OneOf_Value? = nil

  var copiedSheetsValue: PBCopiedSheetsValue {
    get {
      if case .copiedSheetsValue(let v)? = value {return v}
      return PBCopiedSheetsValue()
    }
    set {value = .copiedSheetsValue(newValue)}
  }

  var sheetValue: PBSheetValue {
    get {
      if case .sheetValue(let v)? = value {return v}
      return PBSheetValue()
    }
    set {value = .sheetValue(newValue)}
  }

  var border: PBBorder {
    get {
      if case .border(let v)? = value {return v}
      return PBBorder()
    }
    set {value = .border(newValue)}
  }

  var text: PBText {
    get {
      if case .text(let v)? = value {return v}
      return PBText()
    }
    set {value = .text(newValue)}
  }

  var string: String {
    get {
      if case .string(let v)? = value {return v}
      return String()
    }
    set {value = .string(newValue)}
  }

  var picture: PBPicture {
    get {
      if case .picture(let v)? = value {return v}
      return PBPicture()
    }
    set {value = .picture(newValue)}
  }

  var planesValue: PBPlanesValue {
    get {
      if case .planesValue(let v)? = value {return v}
      return PBPlanesValue()
    }
    set {value = .planesValue(newValue)}
  }

  var uuColor: PBUUColor {
    get {
      if case .uuColor(let v)? = value {return v}
      return PBUUColor()
    }
    set {value = .uuColor(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case copiedSheetsValue(PBCopiedSheetsValue)
    case sheetValue(PBSheetValue)
    case border(PBBorder)
    case text(PBText)
    case string(String)
    case picture(PBPicture)
    case planesValue(PBPlanesValue)
    case uuColor(PBUUColor)

  #if !swift(>=4.1)
    static func ==(lhs: PBPastableObject.OneOf_Value, rhs: PBPastableObject.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.copiedSheetsValue, .copiedSheetsValue): return {
        guard case .copiedSheetsValue(let l) = lhs, case .copiedSheetsValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sheetValue, .sheetValue): return {
        guard case .sheetValue(let l) = lhs, case .sheetValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.border, .border): return {
        guard case .border(let l) = lhs, case .border(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.string, .string): return {
        guard case .string(let l) = lhs, case .string(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.picture, .picture): return {
        guard case .picture(let l) = lhs, case .picture(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.planesValue, .planesValue): return {
        guard case .planesValue(let l) = lhs, case .planesValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uuColor, .uuColor): return {
        guard case .uuColor(let l) = lhs, case .uuColor(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension PBRGBColorSpace: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "sRGB"),
  ]
}

extension PBOrientation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "horizontal"),
    1: .same(proto: "vertical"),
  ]
}

extension PBRectCorner: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "minXMinY"),
    1: .same(proto: "minXMaxY"),
    2: .same(proto: "maxXMinY"),
    3: .same(proto: "maxXMaxY"),
  ]
}

extension PBPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBPoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.y) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBPoint, rhs: PBPoint) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBIntPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBIntPoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.x) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.y) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularInt64Field(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularInt64Field(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBIntPoint, rhs: PBIntPoint) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBSize"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.width) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularDoubleField(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularDoubleField(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBSize, rhs: PBSize) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBRect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBRect"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "origin"),
    2: .same(proto: "size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBRect, rhs: PBRect) -> Bool {
    if lhs._origin != rhs._origin {return false}
    if lhs._size != rhs._size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBAttitude: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBAttitude"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .same(proto: "scale"),
    3: .same(proto: "rotation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._scale) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.rotation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._scale {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.rotation != 0 {
      try visitor.visitSingularDoubleField(value: self.rotation, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBAttitude, rhs: PBAttitude) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs._scale != rhs._scale {return false}
    if lhs.rotation != rhs.rotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBLCHA: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBLCHA"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "l"),
    2: .same(proto: "c"),
    3: .same(proto: "h"),
    4: .same(proto: "a"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.l) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.c) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.h) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.a) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.l != 0 {
      try visitor.visitSingularDoubleField(value: self.l, fieldNumber: 1)
    }
    if self.c != 0 {
      try visitor.visitSingularDoubleField(value: self.c, fieldNumber: 2)
    }
    if self.h != 0 {
      try visitor.visitSingularDoubleField(value: self.h, fieldNumber: 3)
    }
    if self.a != 0 {
      try visitor.visitSingularDoubleField(value: self.a, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBLCHA, rhs: PBLCHA) -> Bool {
    if lhs.l != rhs.l {return false}
    if lhs.c != rhs.c {return false}
    if lhs.h != rhs.h {return false}
    if lhs.a != rhs.a {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBRGBA: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBRGBA"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "r"),
    2: .same(proto: "g"),
    3: .same(proto: "b"),
    4: .same(proto: "a"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.r) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.g) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.b) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.a) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.r != 0 {
      try visitor.visitSingularFloatField(value: self.r, fieldNumber: 1)
    }
    if self.g != 0 {
      try visitor.visitSingularFloatField(value: self.g, fieldNumber: 2)
    }
    if self.b != 0 {
      try visitor.visitSingularFloatField(value: self.b, fieldNumber: 3)
    }
    if self.a != 0 {
      try visitor.visitSingularFloatField(value: self.a, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBRGBA, rhs: PBRGBA) -> Bool {
    if lhs.r != rhs.r {return false}
    if lhs.g != rhs.g {return false}
    if lhs.b != rhs.b {return false}
    if lhs.a != rhs.a {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBColor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBColor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lcha"),
    2: .same(proto: "rgba"),
    3: .same(proto: "rgbColorSpace"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._lcha) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rgba) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.rgbColorSpace) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._lcha {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._rgba {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.rgbColorSpace != .sRgb {
      try visitor.visitSingularEnumField(value: self.rgbColorSpace, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBColor, rhs: PBColor) -> Bool {
    if lhs._lcha != rhs._lcha {return false}
    if lhs._rgba != rhs._rgba {return false}
    if lhs.rgbColorSpace != rhs.rgbColorSpace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBUUID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBUUID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBUUID, rhs: PBUUID) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBUUColor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBUUColor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBUUColor, rhs: PBUUColor) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBLine: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBLine"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "controls"),
    2: .same(proto: "size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.controls) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.controls.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.controls, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularDoubleField(value: self.size, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBLine, rhs: PBLine) -> Bool {
    if lhs.controls != rhs.controls {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBLine.PBControl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = PBLine.protoMessageName + ".PBControl"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "point"),
    2: .same(proto: "weight"),
    3: .same(proto: "pressure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._point) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.weight) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.pressure) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._point {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.weight != 0 {
      try visitor.visitSingularDoubleField(value: self.weight, fieldNumber: 2)
    }
    if self.pressure != 0 {
      try visitor.visitSingularDoubleField(value: self.pressure, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBLine.PBControl, rhs: PBLine.PBControl) -> Bool {
    if lhs._point != rhs._point {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs.pressure != rhs.pressure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPolygon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBPolygon"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.points) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBPolygon, rhs: PBPolygon) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPlane: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBPlane"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "polygon"),
    2: .same(proto: "uuColor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._uuColor) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._polygon) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._uuColor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._polygon {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBPlane, rhs: PBPlane) -> Bool {
    if lhs._polygon != rhs._polygon {return false}
    if lhs._uuColor != rhs._uuColor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPicture: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBPicture"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lines"),
    2: .same(proto: "planes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.lines) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.planes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lines.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lines, fieldNumber: 1)
    }
    if !self.planes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.planes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBPicture, rhs: PBPicture) -> Bool {
    if lhs.lines != rhs.lines {return false}
    if lhs.planes != rhs.planes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBText"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "string"),
    2: .same(proto: "orientation"),
    3: .same(proto: "size"),
    4: .same(proto: "widthCount"),
    5: .same(proto: "origin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.string) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.orientation) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.size) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.widthCount) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.string.isEmpty {
      try visitor.visitSingularStringField(value: self.string, fieldNumber: 1)
    }
    if self.orientation != .horizontal {
      try visitor.visitSingularEnumField(value: self.orientation, fieldNumber: 2)
    }
    if self.size != 0 {
      try visitor.visitSingularDoubleField(value: self.size, fieldNumber: 3)
    }
    if self.widthCount != 0 {
      try visitor.visitSingularDoubleField(value: self.widthCount, fieldNumber: 4)
    }
    if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBText, rhs: PBText) -> Bool {
    if lhs.string != rhs.string {return false}
    if lhs.orientation != rhs.orientation {return false}
    if lhs.size != rhs.size {return false}
    if lhs.widthCount != rhs.widthCount {return false}
    if lhs._origin != rhs._origin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBBorder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBBorder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
    2: .same(proto: "orientation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.location) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.orientation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.location != 0 {
      try visitor.visitSingularDoubleField(value: self.location, fieldNumber: 1)
    }
    if self.orientation != .horizontal {
      try visitor.visitSingularEnumField(value: self.orientation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBBorder, rhs: PBBorder) -> Bool {
    if lhs.location != rhs.location {return false}
    if lhs.orientation != rhs.orientation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBIntPointStringDic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBIntPointStringDic"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,PBIntPoint>.self, value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,PBIntPoint>.self, value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBIntPointStringDic, rhs: PBIntPointStringDic) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBStringIntPointDicElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBStringIntPointDicElement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBStringIntPointDicElement, rhs: PBStringIntPointDicElement) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBStringIntPointDic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBStringIntPointDic"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBStringIntPointDic, rhs: PBStringIntPointDic) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBSheet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBSheet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "picture"),
    2: .same(proto: "draftPicture"),
    3: .same(proto: "texts"),
    4: .same(proto: "borders"),
    5: .same(proto: "backgroundUUColor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._picture) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._draftPicture) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.texts) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.borders) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._backgroundUucolor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._picture {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._draftPicture {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.texts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.texts, fieldNumber: 3)
    }
    if !self.borders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.borders, fieldNumber: 4)
    }
    if let v = self._backgroundUucolor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBSheet, rhs: PBSheet) -> Bool {
    if lhs._picture != rhs._picture {return false}
    if lhs._draftPicture != rhs._draftPicture {return false}
    if lhs.texts != rhs.texts {return false}
    if lhs.borders != rhs.borders {return false}
    if lhs._backgroundUucolor != rhs._backgroundUucolor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBWorld: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBWorld"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sheetPositions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sheetPositions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sheetPositions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBWorld, rhs: PBWorld) -> Bool {
    if lhs._sheetPositions != rhs._sheetPositions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCornerRectValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBCornerRectValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rect"),
    2: .same(proto: "rectCorner"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rect) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.rectCorner) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._rect {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.rectCorner != .minXminY {
      try visitor.visitSingularEnumField(value: self.rectCorner, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCornerRectValue, rhs: PBCornerRectValue) -> Bool {
    if lhs._rect != rhs._rect {return false}
    if lhs.rectCorner != rhs.rectCorner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCornerRectValueArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBCornerRectValueArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCornerRectValueArray, rhs: PBCornerRectValueArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBFinding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBFinding"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "worldPosition"),
    2: .same(proto: "string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._worldPosition) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.string) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._worldPosition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.string.isEmpty {
      try visitor.visitSingularStringField(value: self.string, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBFinding, rhs: PBFinding) -> Bool {
    if lhs._worldPosition != rhs._worldPosition {return false}
    if lhs.string != rhs.string {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBIntIndexValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBIntIndexValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBIntIndexValue, rhs: PBIntIndexValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBLineIndexValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBLineIndexValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBLineIndexValue, rhs: PBLineIndexValue) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPlaneIndexValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBPlaneIndexValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBPlaneIndexValue, rhs: PBPlaneIndexValue) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBTextIndexValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBTextIndexValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBTextIndexValue, rhs: PBTextIndexValue) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBBorderIndexValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBBorderIndexValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBBorderIndexValue, rhs: PBBorderIndexValue) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBColorValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBColorValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuColor"),
    3: .same(proto: "planeIndexes"),
    5: .same(proto: "isBackground"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuColor) }()
      case 3: try { try decoder.decodeRepeatedInt64Field(value: &self.planeIndexes) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isBackground) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._uuColor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.planeIndexes.isEmpty {
      try visitor.visitPackedInt64Field(value: self.planeIndexes, fieldNumber: 3)
    }
    if self.isBackground != false {
      try visitor.visitSingularBoolField(value: self.isBackground, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBColorValue, rhs: PBColorValue) -> Bool {
    if lhs._uuColor != rhs._uuColor {return false}
    if lhs.planeIndexes != rhs.planeIndexes {return false}
    if lhs.isBackground != rhs.isBackground {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBIntClosedRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBIntClosedRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lowerBound"),
    2: .same(proto: "upperBound"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.lowerBound) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.upperBound) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lowerBound != 0 {
      try visitor.visitSingularInt64Field(value: self.lowerBound, fieldNumber: 1)
    }
    if self.upperBound != 0 {
      try visitor.visitSingularInt64Field(value: self.upperBound, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBIntClosedRange, rhs: PBIntClosedRange) -> Bool {
    if lhs.lowerBound != rhs.lowerBound {return false}
    if lhs.upperBound != rhs.upperBound {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPlaneValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBPlaneValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "planes"),
    2: .same(proto: "moveIndexValues"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.planes) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.moveIndexValues) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.planes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.planes, fieldNumber: 1)
    }
    if !self.moveIndexValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.moveIndexValues, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBPlaneValue, rhs: PBPlaneValue) -> Bool {
    if lhs.planes != rhs.planes {return false}
    if lhs.moveIndexValues != rhs.moveIndexValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBTextValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBTextValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "string"),
    2: .same(proto: "replacedRange"),
    3: .same(proto: "origin"),
    4: .same(proto: "size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.string) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._replacedRange) }()
      case 3: try {
        var v: PBPoint?
        if let current = self.originOptional {
          try decoder.handleConflictingOneOf()
          if case .origin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.originOptional = .origin(v)}
      }()
      case 4: try {
        if self.sizeOptional != nil {try decoder.handleConflictingOneOf()}
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {self.sizeOptional = .size(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.string.isEmpty {
      try visitor.visitSingularStringField(value: self.string, fieldNumber: 1)
    }
    if let v = self._replacedRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if case .origin(let v)? = self.originOptional {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if case .size(let v)? = self.sizeOptional {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBTextValue, rhs: PBTextValue) -> Bool {
    if lhs.string != rhs.string {return false}
    if lhs._replacedRange != rhs._replacedRange {return false}
    if lhs.originOptional != rhs.originOptional {return false}
    if lhs.sizeOptional != rhs.sizeOptional {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBTextValueIndexValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBTextValueIndexValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBTextValueIndexValue, rhs: PBTextValueIndexValue) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBSheetValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBSheetValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lines"),
    2: .same(proto: "planes"),
    3: .same(proto: "texts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.lines) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.planes) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.texts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lines.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lines, fieldNumber: 1)
    }
    if !self.planes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.planes, fieldNumber: 2)
    }
    if !self.texts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.texts, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBSheetValue, rhs: PBSheetValue) -> Bool {
    if lhs.lines != rhs.lines {return false}
    if lhs.planes != rhs.planes {return false}
    if lhs.texts != rhs.texts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBInt64Array: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBInt64Array"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitPackedInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBInt64Array, rhs: PBInt64Array) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBLineArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBLineArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBLineArray, rhs: PBLineArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPlaneArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBPlaneArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBPlaneArray, rhs: PBPlaneArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBIntPointArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBIntPointArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBIntPointArray, rhs: PBIntPointArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBIntIndexValueArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBIntIndexValueArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBIntIndexValueArray, rhs: PBIntIndexValueArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBLineIndexValueArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBLineIndexValueArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBLineIndexValueArray, rhs: PBLineIndexValueArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPlaneIndexValueArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBPlaneIndexValueArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBPlaneIndexValueArray, rhs: PBPlaneIndexValueArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBTextIndexValueArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBTextIndexValueArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBTextIndexValueArray, rhs: PBTextIndexValueArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBBorderIndexValueArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBBorderIndexValueArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBBorderIndexValueArray, rhs: PBBorderIndexValueArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBSheetUndoItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBSheetUndoItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appendLine"),
    2: .same(proto: "appendLines"),
    3: .same(proto: "appendPlanes"),
    4: .same(proto: "removeLastLines"),
    5: .same(proto: "removeLastPlanes"),
    6: .same(proto: "insertLines"),
    7: .same(proto: "insertPlanes"),
    8: .same(proto: "removeLines"),
    9: .same(proto: "removePlanes"),
    10: .same(proto: "setPlaneValue"),
    11: .same(proto: "changeToDraft"),
    12: .same(proto: "setPicture"),
    13: .same(proto: "insertDraftLines"),
    14: .same(proto: "insertDraftPlanes"),
    15: .same(proto: "removeDraftLines"),
    16: .same(proto: "removeDraftPlanes"),
    17: .same(proto: "setDraftPicture"),
    18: .same(proto: "insertTexts"),
    19: .same(proto: "removeTexts"),
    20: .same(proto: "replaceString"),
    21: .same(proto: "changedColors"),
    22: .same(proto: "insertBorders"),
    23: .same(proto: "removeBorders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PBLine?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .appendLine(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .appendLine(v)}
      }()
      case 2: try {
        var v: PBLineArray?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .appendLines(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .appendLines(v)}
      }()
      case 3: try {
        var v: PBPlaneArray?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .appendPlanes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .appendPlanes(v)}
      }()
      case 4: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.value = .removeLastLines(v)}
      }()
      case 5: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.value = .removeLastPlanes(v)}
      }()
      case 6: try {
        var v: PBLineIndexValueArray?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .insertLines(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .insertLines(v)}
      }()
      case 7: try {
        var v: PBPlaneIndexValueArray?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .insertPlanes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .insertPlanes(v)}
      }()
      case 8: try {
        var v: PBInt64Array?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .removeLines(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .removeLines(v)}
      }()
      case 9: try {
        var v: PBInt64Array?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .removePlanes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .removePlanes(v)}
      }()
      case 10: try {
        var v: PBPlaneValue?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .setPlaneValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .setPlaneValue(v)}
      }()
      case 11: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.value = .changeToDraft(v)}
      }()
      case 12: try {
        var v: PBPicture?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .setPicture(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .setPicture(v)}
      }()
      case 13: try {
        var v: PBLineIndexValueArray?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .insertDraftLines(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .insertDraftLines(v)}
      }()
      case 14: try {
        var v: PBPlaneIndexValueArray?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .insertDraftPlanes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .insertDraftPlanes(v)}
      }()
      case 15: try {
        var v: PBInt64Array?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .removeDraftLines(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .removeDraftLines(v)}
      }()
      case 16: try {
        var v: PBInt64Array?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .removeDraftPlanes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .removeDraftPlanes(v)}
      }()
      case 17: try {
        var v: PBPicture?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .setDraftPicture(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .setDraftPicture(v)}
      }()
      case 18: try {
        var v: PBTextIndexValueArray?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .insertTexts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .insertTexts(v)}
      }()
      case 19: try {
        var v: PBInt64Array?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .removeTexts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .removeTexts(v)}
      }()
      case 20: try {
        var v: PBTextValueIndexValue?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .replaceString(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .replaceString(v)}
      }()
      case 21: try {
        var v: PBColorValue?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .changedColors(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .changedColors(v)}
      }()
      case 22: try {
        var v: PBBorderIndexValueArray?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .insertBorders(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .insertBorders(v)}
      }()
      case 23: try {
        var v: PBInt64Array?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .removeBorders(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .removeBorders(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.value {
    case .appendLine?: try {
      guard case .appendLine(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .appendLines?: try {
      guard case .appendLines(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .appendPlanes?: try {
      guard case .appendPlanes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .removeLastLines?: try {
      guard case .removeLastLines(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    }()
    case .removeLastPlanes?: try {
      guard case .removeLastPlanes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    }()
    case .insertLines?: try {
      guard case .insertLines(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .insertPlanes?: try {
      guard case .insertPlanes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .removeLines?: try {
      guard case .removeLines(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .removePlanes?: try {
      guard case .removePlanes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .setPlaneValue?: try {
      guard case .setPlaneValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .changeToDraft?: try {
      guard case .changeToDraft(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
    }()
    case .setPicture?: try {
      guard case .setPicture(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .insertDraftLines?: try {
      guard case .insertDraftLines(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .insertDraftPlanes?: try {
      guard case .insertDraftPlanes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .removeDraftLines?: try {
      guard case .removeDraftLines(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .removeDraftPlanes?: try {
      guard case .removeDraftPlanes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .setDraftPicture?: try {
      guard case .setDraftPicture(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .insertTexts?: try {
      guard case .insertTexts(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .removeTexts?: try {
      guard case .removeTexts(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .replaceString?: try {
      guard case .replaceString(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .changedColors?: try {
      guard case .changedColors(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .insertBorders?: try {
      guard case .insertBorders(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .removeBorders?: try {
      guard case .removeBorders(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBSheetUndoItem, rhs: PBSheetUndoItem) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBWorldUndoItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBWorldUndoItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "insertSheets"),
    2: .same(proto: "removeSheets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PBStringIntPointDic?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .insertSheets(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .insertSheets(v)}
      }()
      case 2: try {
        var v: PBIntPointArray?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .removeSheets(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .removeSheets(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.value {
    case .insertSheets?: try {
      guard case .insertSheets(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .removeSheets?: try {
      guard case .removeSheets(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBWorldUndoItem, rhs: PBWorldUndoItem) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBUndoDataValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBUndoDataValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "undoItemData"),
    2: .same(proto: "redoItemData"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.undoItemData) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.redoItemData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.undoItemData.isEmpty {
      try visitor.visitSingularBytesField(value: self.undoItemData, fieldNumber: 1)
    }
    if !self.redoItemData.isEmpty {
      try visitor.visitSingularBytesField(value: self.redoItemData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBUndoDataValue, rhs: PBUndoDataValue) -> Bool {
    if lhs.undoItemData != rhs.undoItemData {return false}
    if lhs.redoItemData != rhs.redoItemData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBUndoGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBUndoGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBUndoGroup, rhs: PBUndoGroup) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBBranch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBBranch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groups"),
    2: .same(proto: "childrenCount"),
    3: .same(proto: "selectedChildIndex"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groups) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.childrenCount) }()
      case 3: try {
        if self.selectedChildIndexOptional != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.selectedChildIndexOptional = .selectedChildIndex(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 1)
    }
    if self.childrenCount != 0 {
      try visitor.visitSingularInt64Field(value: self.childrenCount, fieldNumber: 2)
    }
    if case .selectedChildIndex(let v)? = self.selectedChildIndexOptional {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBBranch, rhs: PBBranch) -> Bool {
    if lhs.groups != rhs.groups {return false}
    if lhs.childrenCount != rhs.childrenCount {return false}
    if lhs.selectedChildIndexOptional != rhs.selectedChildIndexOptional {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBBranchCoder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBBranchCoder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "allBranches"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.allBranches) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allBranches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allBranches, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBBranchCoder, rhs: PBBranchCoder) -> Bool {
    if lhs.allBranches != rhs.allBranches {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBHistory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBHistory"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "branchCoder"),
    2: .same(proto: "currentVersionIndex"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._branchCoder) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.currentVersionIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._branchCoder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.currentVersionIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.currentVersionIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBHistory, rhs: PBHistory) -> Bool {
    if lhs._branchCoder != rhs._branchCoder {return false}
    if lhs.currentVersionIndex != rhs.currentVersionIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCopiedSheetsValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBCopiedSheetsValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deltaPoint"),
    2: .same(proto: "sheetIDs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._deltaPoint) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sheetIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._deltaPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._sheetIds {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCopiedSheetsValue, rhs: PBCopiedSheetsValue) -> Bool {
    if lhs._deltaPoint != rhs._deltaPoint {return false}
    if lhs._sheetIds != rhs._sheetIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPlanesValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBPlanesValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "planes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.planes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.planes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.planes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBPlanesValue, rhs: PBPlanesValue) -> Bool {
    if lhs.planes != rhs.planes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPastableObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBPastableObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "copiedSheetsValue"),
    2: .same(proto: "sheetValue"),
    3: .same(proto: "border"),
    4: .same(proto: "text"),
    5: .same(proto: "string"),
    6: .same(proto: "picture"),
    7: .same(proto: "planesValue"),
    8: .same(proto: "uuColor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PBCopiedSheetsValue?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .copiedSheetsValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .copiedSheetsValue(v)}
      }()
      case 2: try {
        var v: PBSheetValue?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .sheetValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .sheetValue(v)}
      }()
      case 3: try {
        var v: PBBorder?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .border(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .border(v)}
      }()
      case 4: try {
        var v: PBText?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .text(v)}
      }()
      case 5: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.value = .string(v)}
      }()
      case 6: try {
        var v: PBPicture?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .picture(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .picture(v)}
      }()
      case 7: try {
        var v: PBPlanesValue?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .planesValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .planesValue(v)}
      }()
      case 8: try {
        var v: PBUUColor?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .uuColor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .uuColor(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.value {
    case .copiedSheetsValue?: try {
      guard case .copiedSheetsValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .sheetValue?: try {
      guard case .sheetValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .border?: try {
      guard case .border(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .text?: try {
      guard case .text(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .string?: try {
      guard case .string(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case .picture?: try {
      guard case .picture(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .planesValue?: try {
      guard case .planesValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .uuColor?: try {
      guard case .uuColor(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBPastableObject, rhs: PBPastableObject) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
